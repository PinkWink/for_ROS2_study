<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Pinky Pro Web Nav + SLAM Console</title>
  <style>
    :root {
      --pink-start: #ff6bb8;
      --pink-end: #ff9ad4;
      --blue-start: #5069d8;
      --blue-end: #7a9be8;
      --bg-dark: #0f172a;
      --card-bg: #0b1020;
      --border-subtle: rgba(255, 255, 255, 0.08);
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --accent: #ff9ad4;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      height: 100vh;
      display: flex;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top left, #201537, #020617 55%, #000000 100%);
      color: var(--text-main);
    }

    /* ÏôºÏ™Ω: Î©îÏù∏ Îßµ Ïπ¥Îìú */
    #left {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .map-card {
      width: 100%;
      max-width: 900px;
      border-radius: 24px;
      padding: 16px 16px 20px 16px;
      background:
        radial-gradient(circle at top left, rgba(255, 155, 210, 0.12), transparent 55%),
        radial-gradient(circle at bottom right, rgba(104, 166, 255, 0.12), transparent 55%),
        var(--card-bg);
      box-shadow:
        0 20px 40px rgba(0, 0, 0, 0.8),
        0 0 0 1px rgba(255, 255, 255, 0.04);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      position: relative;
      overflow: hidden;
    }

    .map-card-header {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 4px 8px 4px;
    }

    .map-title {
      font-size: 16px;
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .map-title span {
      background: linear-gradient(135deg, var(--pink-start), var(--blue-end));
      -webkit-background-clip: text;
      color: transparent;
    }

    .chip {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(15, 23, 42, 0.7);
      backdrop-filter: blur(10px);
    }

    .chip-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: radial-gradient(circle, #22c55e, #15803d);
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.9);
    }

    canvas {
      border-radius: 18px;
      background: #000;
      border: 1px solid var(--border-subtle);
    }

    .map-hint {
      font-size: 12px;
      color: var(--text-muted);
    }

    /* Ïò§Î•∏Ï™Ω: Ïª®Ìä∏Î°§ Ìå®ÎÑê */
    #right {
      width: 340px;
      padding: 20px 18px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      border-left: 1px solid rgba(15, 23, 42, 0.9);
      background: radial-gradient(circle at top, rgba(248, 113, 185, 0.12), transparent 65%),
                  radial-gradient(circle at bottom, rgba(56, 189, 248, 0.12), transparent 65%),
                  #020617;
    }

    .panel-card {
      background: rgba(15, 23, 42, 0.85);
      border-radius: 18px;
      padding: 14px 14px 12px 14px;
      border: 1px solid var(--border-subtle);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.7);
    }

    /* Ìó§Îçî */
    .header-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .logo-wrap {
      width: 34px;
      height: 34px;
      border-radius: 12px;
      background: radial-gradient(circle at top left, var(--pink-start), var(--blue-start));
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .logo-wrap img {
      width: 28px;
      height: 28px;
      object-fit: contain;
      display: block;
    }

    .header-text-main {
      font-size: 14px;
      font-weight: 600;
    }

    .header-text-sub {
      font-size: 11px;
      color: var(--text-muted);
    }

    .info-line {
      font-size: 12px;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    .info-line span.value {
      color: var(--text-main);
      font-weight: 500;
      font-variant-numeric: tabular-nums;
    }

    /* ÏÑπÏÖò ÌÉÄÏù¥ÌãÄ */
    .section-title {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      margin-bottom: 6px;
    }

    /* ÌÜ†Í∏Ä Ïä§ÏúÑÏπò */
    .layer-row {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 0;
      font-size: 13px;
      color: var(--text-main);
    }

    .toggle-left {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
    }

    .legend-global {
      background: linear-gradient(135deg, #38bdf8, #22c1c3);
    }

    .legend-local {
      background: linear-gradient(135deg, #7c3aed, #4c1d95);
    }

    .legend-free {
      background: #ffffff;
      border: 1px solid #e5e7eb;
    }

    .legend-obstacle {
      background: #000000;
      border: 1px solid #111827;
    }

    .toggle input {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }

    .switch {
      width: 36px;
      height: 20px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.6);
      position: relative;
      cursor: pointer;
      transition: background 0.18s ease, border-color 0.18s ease;
    }

    .switch-knob {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      background: #e5e7eb;
      position: absolute;
      top: 2px;
      left: 2px;
      transition: transform 0.18s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }

    .toggle input:checked + .switch {
      background: linear-gradient(135deg, var(--pink-start), var(--blue-end));
      border-color: transparent;
    }

    .toggle input:checked + .switch .switch-knob {
      transform: translateX(14px);
      background: #0b1120;
    }

    /* Legend */
    .legend-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 10px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    /* ÏûëÏùÄ Ìë∏ÌÑ∞ ÌÖçÏä§Ìä∏ */
    .tiny-note {
      margin-top: 4px;
      font-size: 11px;
      color: var(--text-muted);
    }

    /* SLAM Ïπ¥Îìú Ï†ÑÏö© */
    .slam-input-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .text-input {
      flex: 1;
      padding: 6px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.8);
      color: var(--text-main);
      font-size: 12px;
      outline: none;
    }

    .text-input::placeholder {
      color: rgba(148, 163, 184, 0.7);
    }

    .slam-actions {
      display: flex;
      gap: 8px;
      margin-bottom: 4px;
    }

    .btn {
      flex: 1;
      padding: 6px 8px;
      border-radius: 999px;
      border: 1px solid transparent;
      font-size: 12px;
      cursor: pointer;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      background: transparent;
      color: var(--text-main);
      transition: background 0.15s ease, border-color 0.15s ease, transform 0.07s ease;
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--pink-start), var(--blue-end));
      border-color: transparent;
      color: #020617;
    }

    .btn-primary:hover {
      filter: brightness(1.05);
    }

    .btn-outline {
      border-color: rgba(148, 163, 184, 0.8);
      background: rgba(15, 23, 42, 0.8);
      color: var(--text-main);
    }

    .btn-outline:hover {
      border-color: var(--accent);
    }

    .slam-status {
      font-size: 11px;
      color: var(--text-muted);
      min-height: 14px;
    }

    .slam-status.ok {
      color: #4ade80;
    }

    .slam-status.err {
      color: #fb7185;
    }
  </style>
</head>
<body>
<div id="left">
  <div class="map-card">
    <div class="map-card-header">
      <div class="map-title">Pinky Pro <span>Navigation</span></div>
      <div class="chip">
        <span class="chip-dot"></span>
        LIVE
      </div>
    </div>

    <canvas id="mapCanvas" width="720" height="720"></canvas>

    <div class="map-hint">
      üñ±Ô∏è ÏßÄÎèÑÏóêÏÑú <b>ÌÅ¥Î¶≠ ÌõÑ ÎìúÎûòÍ∑∏</b>ÌïòÎ©¥ 2D Nav Goal (ÏúÑÏπò + Î∞©Ìñ•)Ïù¥ Ï†ÑÏÜ°Îê©ÎãàÎã§.
    </div>
  </div>
</div>

<div id="right">
  <!-- Ìó§Îçî Ïπ¥Îìú -->
  <div class="panel-card">
    <div class="header-row">
      <div class="logo-wrap">
        <!-- Î°úÍ≥† ÌååÏùºÎ™ÖÏùÑ ÌôòÍ≤ΩÏóê ÎßûÍ≤å Î≥ÄÍ≤ΩÌïòÏÑ∏Ïöî -->
        <img src="pinklab_logo.png" alt="PinkLab Logo">
      </div>
      <div>
        <div class="header-text-main">PinkLab ¬∑ Pinky Pro</div>
        <div class="header-text-sub">Web Navigation & SLAM Console</div>
      </div>
    </div>
    <div class="info-line">
      <span>Robot pose</span>
      <span class="value" id="poseText">-</span>
    </div>
    <div class="info-line">
      <span>Last update</span>
      <span class="value" id="updateText">-</span>
    </div>
  </div>

  <!-- Layers Ïπ¥Îìú -->
  <div class="panel-card">
    <div class="section-title">Layers</div>
    <div class="layer-row">
      <label class="toggle">
        <div class="toggle-left">
          <span class="legend-dot legend-global"></span>
          <span>Global costmap</span>
        </div>
        <div>
          <input type="checkbox" id="toggleGlobal" checked>
          <div class="switch">
            <div class="switch-knob"></div>
          </div>
        </div>
      </label>

      <label class="toggle">
        <div class="toggle-left">
          <span class="legend-dot legend-local"></span>
          <span>Local costmap</span>
        </div>
        <div>
          <input type="checkbox" id="toggleLocal" checked>
          <div class="switch">
            <div class="switch-knob"></div>
          </div>
        </div>
      </label>
    </div>
  </div>

  <!-- SLAM Mapping Ïπ¥Îìú -->
  <div class="panel-card">
    <div class="section-title">SLAM Mapping (slam_toolbox)</div>
    <div class="slam-input-row">
      <input
        type="text"
        id="mapNameInput"
        class="text-input"
        placeholder="map name (e.g. pinky_lab)"
        value="pinky_map">
    </div>
    <div class="slam-actions">
      <button id="btnSlamReset" class="btn btn-outline">
        Reset Map
      </button>
      <button id="btnSlamSave" class="btn btn-primary">
        Save Map
      </button>
    </div>
    <div id="slamStatus" class="slam-status">
      <!-- ÏÉÅÌÉú Î©îÏãúÏßÄ -->
    </div>
  </div>

  <!-- Legend Ïπ¥Îìú -->
  <div class="panel-card">
    <div class="section-title">Legend</div>
    <div class="legend-row">
      <span class="legend-item">
        <span class="legend-dot legend-free"></span>
        <span>Free</span>
      </span>
      <span class="legend-item">
        <span class="legend-dot legend-obstacle"></span>
        <span>Obstacle</span>
      </span>
      <span class="legend-item">
        <span class="legend-dot legend-global"></span>
        <span>Global costmap</span>
      </span>
      <span class="legend-item">
        <span class="legend-dot legend-local"></span>
        <span>Local costmap</span>
      </span>
    </div>
    <div class="tiny-note">
      üìå RVizÏôÄ ÎèôÏùºÌïú Ï¢åÌëúÍ≥Ñ(<b>map</b> frame Í∏∞Ï§Ä)ÏûÖÎãàÎã§.
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById("mapCanvas");
const ctx = canvas.getContext("2d");

let latestState = null;

// layer toggle ÏÉÅÌÉú
let showGlobalCostmap = true;
let showLocalCostmap = true;

// goal ÎìúÎûòÍ∑∏ ÏÉÅÌÉú
let isDraggingGoal = false;
let goalStartWorld = null;     // {x,y} world Ï¢åÌëú
let goalCurrentCanvas = null;  // {x,y} canvas Ï¢åÌëú (ÎØ∏Î¶¨Î≥¥Í∏∞Ïö©)

// SLAM UI ÏöîÏÜå
const slamStatusEl = document.getElementById("slamStatus");
const mapNameInput = document.getElementById("mapNameInput");
const btnSlamReset = document.getElementById("btnSlamReset");
const btnSlamSave = document.getElementById("btnSlamSave");

// ÌÜ†Í∏Ä Ïù¥Î≤§Ìä∏ Ïó∞Í≤∞
document.getElementById("toggleGlobal").addEventListener("change", (e) => {
  showGlobalCostmap = e.target.checked;
  drawState();
});

document.getElementById("toggleLocal").addEventListener("change", (e) => {
  showLocalCostmap = e.target.checked;
  drawState();
});

// SLAM Î≤ÑÌäº Ïù¥Î≤§Ìä∏
btnSlamReset.addEventListener("click", async () => {
  slamStatusEl.classList.remove("ok", "err");
  slamStatusEl.textContent = "Resetting SLAM map...";

  try {
    const res = await fetch("/api/slam/reset", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({}),
    });
    const data = await res.json();
    if (data.success) {
      slamStatusEl.classList.add("ok");
      slamStatusEl.textContent = "SLAM reset requested. Start driving to build a new map.";
    } else {
      slamStatusEl.classList.add("err");
      slamStatusEl.textContent = "Failed to call /slam_toolbox/reset: " + (data.msg || "");
    }
  } catch (e) {
    console.error(e);
    slamStatusEl.classList.add("err");
    slamStatusEl.textContent = "Error while calling SLAM reset.";
  }
});

btnSlamSave.addEventListener("click", async () => {
  slamStatusEl.classList.remove("ok", "err");
  const name = (mapNameInput.value || "").trim();
  slamStatusEl.textContent = "Saving map" + (name ? ` '${name}'...` : "...");

  try {
    const res = await fetch("/api/slam/save_map", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ name }),
    });
    const data = await res.json();
    if (data.success) {
      slamStatusEl.classList.add("ok");
      slamStatusEl.textContent =
        `SaveMap requested. Files will be saved as '${data.name}.pgm/.yaml' (current working dir of slam_toolbox).`;
    } else {
      slamStatusEl.classList.add("err");
      slamStatusEl.textContent = "Failed to call /slam_toolbox/save_map: " + (data.msg || "");
    }
  } catch (e) {
    console.error(e);
    slamStatusEl.classList.add("err");
    slamStatusEl.textContent = "Error while calling SaveMap.";
  }
});

// ÏÑúÎ≤ÑÏóêÏÑú ÏÉÅÌÉú Í∞ÄÏ†∏Ïò§Í∏∞
async function fetchState() {
  try {
    const res = await fetch("/api/state");
    if (!res.ok) return;
    const data = await res.json();
    latestState = data;
    drawState();
    document.getElementById("updateText").innerText = new Date().toLocaleTimeString();

    if (data.pose) {
      const p = data.pose;
      document.getElementById("poseText").innerText =
        `x=${p.x.toFixed(2)}, y=${p.y.toFixed(2)}, yaw=${p.yaw.toFixed(2)}`;
    } else {
      document.getElementById("poseText").innerText = "-";
    }
  } catch (e) {
    console.error(e);
  }
}

// Îßµ / Î°úÎ¥á / Í≤ΩÎ°ú / global/local costmap Í∑∏Î¶¨Í∏∞
function drawState() {
  if (!latestState || !latestState.map) {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    return;
  }

  const map = latestState.map;
  const pose = latestState.pose;
  const path = latestState.path || [];
  const local = latestState.local_costmap;
  const globalC = latestState.global_costmap;

  const width = map.width;
  const height = map.height;
  const data = map.data;
  const resolution = map.resolution;
  const origin = map.origin;

  // Ï∫îÎ≤ÑÏä§ Ï¥àÍ∏∞Ìôî
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // ÎßµÏùÑ Ï∫îÎ≤ÑÏä§Ïóê ÎßûÍ≤å Ïä§ÏºÄÏùº
  const scaleX = canvas.width / width;
  const scaleY = canvas.height / height;
  const scale = Math.min(scaleX, scaleY);

  // (ÏÖÄ Ï¢åÌëú -> Ï∫îÎ≤ÑÏä§ Ï¢åÌëú)
  function cellToCanvas(ix, iy) {
    const px = ix * scale;
    const py = (height - 1 - iy) * scale; // y Îí§ÏßëÍ∏∞
    return [px, py];
  }

  // (world -> Ï∫îÎ≤ÑÏä§)
  function worldToCanvas(wx, wy) {
    const mx = (wx - origin.x) / resolution;
    const my = (wy - origin.y) / resolution;
    return cellToCanvas(mx, my);
  }

  // ---- global map Í∑∏Î¶¨Í∏∞ ----
  for (let iy = 0; iy < height; iy++) {
    for (let ix = 0; ix < width; ix++) {
      const idx = iy * width + ix;
      const v = data[idx]; // -1: unknown, 0: free, 100: occupied ...

      if (v < 0) {
        ctx.fillStyle = "#4b5563";    // unknown: Ï§ëÍ∞Ñ ÌöåÏÉâ
      } else if (v === 0) {
        ctx.fillStyle = "#ffffff";    // free: Ìù∞ÏÉâ
      } else if (v >= 100) {
        ctx.fillStyle = "#000000";    // obstacle: Í≤ÄÏ†ï
      } else {
        ctx.fillStyle = "#d1d5db";    // ÏïΩÍ∞Ñ ÎπÑÏö© ÏûàÎäî free
      }

      const [px, py] = cellToCanvas(ix, iy);
      ctx.fillRect(px, py, scale, scale);
    }
  }

  // ---- GLOBAL costmap (Ïù∏ÌîåÎ†àÏù¥ÏÖò ÎßÅ) Ïò§Î≤ÑÎ†àÏù¥ ----
  if (showGlobalCostmap && globalC && globalC.data && globalC.data.length > 0) {
    const gwidth = globalC.width;
    const gheight = globalC.height;
    const gres = globalC.resolution;
    const gorg = globalC.origin;
    const gdata = globalC.data;

    ctx.save();
    ctx.fillStyle = "rgba(56, 189, 248, 0.5)"; // Ïó∞Ìïú ÌïòÎäòÏÉâ/Ï≤≠Î°ùÏÉâ

    for (let iy = 0; iy < gheight; iy++) {
      for (let ix = 0; ix < gwidth; ix++) {
        const idx = iy * gwidth + ix;
        const cost = gdata[idx];
        if (cost <= 0) continue;

        const wx = gorg.x + (ix + 0.5) * gres;
        const wy = gorg.y + (iy + 0.5) * gres;
        const [px, py] = worldToCanvas(wx, wy);

        ctx.fillRect(px, py, scale, scale);
      }
    }
    ctx.restore();
  }

  // ---- LOCAL costmap (Î≥¥ÎùºÏÉâ) Ïò§Î≤ÑÎ†àÏù¥ ----
  if (showLocalCostmap && local && local.data && local.data.length > 0) {
    const lwidth = local.width;
    const lheight = local.height;
    const lres = local.resolution;
    const lorg = local.origin;
    const ldata = local.data;

    ctx.save();
    ctx.fillStyle = "rgba(124, 58, 237, 0.7)"; // Î≥¥ÎùºÏÉâ

    for (let iy = 0; iy < lheight; iy++) {
      for (let ix = 0; ix < lwidth; ix++) {
        const idx = iy * lwidth + ix;
        const cost = ldata[idx];
        if (cost <= 0) continue;

        const wx = lorg.x + (ix + 0.5) * lres;
        const wy = lorg.y + (iy + 0.5) * lres;
        const [px, py] = worldToCanvas(wx, wy);

        ctx.fillRect(px, py, scale, scale);
      }
    }
    ctx.restore();
  }

  // ---- path Í∑∏Î¶¨Í∏∞ ----
  if (path.length > 0) {
    ctx.strokeStyle = "#22c55e";
    ctx.lineWidth = 2;
    ctx.beginPath();
    path.forEach((pt, i) => {
      const [px, py] = worldToCanvas(pt.x, pt.y);
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    });
    ctx.stroke();
  }

  // ---- Î°úÎ¥á ÏúÑÏπò (TF Í∏∞Î∞ò pose) ----
  if (pose) {
    const [rx, ry] = worldToCanvas(pose.x, pose.y);
    ctx.fillStyle = "#f97316";
    ctx.beginPath();
    ctx.arc(rx, ry, 6, 0, 2 * Math.PI);
    ctx.fill();

    const len = 20;
    const hx = rx + len * Math.cos(-pose.yaw);
    const hy = ry + len * Math.sin(-pose.yaw);
    ctx.strokeStyle = "#fde68a";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(rx, ry);
    ctx.lineTo(hx, hy);
    ctx.stroke();
  }

  // ---- goal ÎìúÎûòÍ∑∏ ÎØ∏Î¶¨Î≥¥Í∏∞ ----
  if (isDraggingGoal && goalStartWorld && goalCurrentCanvas) {
    const [sx, sy] = worldToCanvas(goalStartWorld.x, goalStartWorld.y);
    const ex = goalCurrentCanvas.x;
    const ey = goalCurrentCanvas.y;

    ctx.strokeStyle = "#fb7185";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(ex, ey);
    ctx.stroke();

    ctx.fillStyle = "#fb7185";
    ctx.beginPath();
    ctx.arc(ex, ey, 4, 0, 2 * Math.PI);
    ctx.fill();
  }
}

// canvas Ï¢åÌëú ‚Üí world Ï¢åÌëú Î≥ÄÌôò (map Í∏∞Ï§Ä)
function canvasToWorld(cx, cy) {
  if (!latestState || !latestState.map) return null;

  const map = latestState.map;
  const width = map.width;
  const height = map.height;
  const resolution = map.resolution;
  const origin = map.origin;

  const scaleX = canvas.width / width;
  const scaleY = canvas.height / height;
  const scale = Math.min(scaleX, scaleY);

  const ix = cx / scale;
  const iy = height - 1 - (cy / scale); // y Îí§ÏßëÍ∏∞

  const wx = origin.x + ix * resolution;
  const wy = origin.y + iy * resolution;

  return { x: wx, y: wy };
}

// ---- goal ÏßÄÏ†ï: ÌÅ¥Î¶≠ + ÎìúÎûòÍ∑∏ ----
canvas.addEventListener("mousedown", (evt) => {
  if (!latestState || !latestState.map) return;

  const rect = canvas.getBoundingClientRect();
  const cx = evt.clientX - rect.left;
  const cy = evt.clientY - rect.top;

  const w = canvasToWorld(cx, cy);
  if (!w) return;

  isDraggingGoal = true;
  goalStartWorld = w;
  goalCurrentCanvas = { x: cx, y: cy };
  drawState(); // ÎØ∏Î¶¨Î≥¥Í∏∞ Í∞±Ïã†
});

canvas.addEventListener("mousemove", (evt) => {
  if (!isDraggingGoal) return;
  const rect = canvas.getBoundingClientRect();
  const cx = evt.clientX - rect.left;
  const cy = evt.clientY - rect.top;

  goalCurrentCanvas = { x: cx, y: cy };
  drawState();
});

canvas.addEventListener("mouseup", async (evt) => {
  if (!isDraggingGoal || !goalStartWorld) {
    isDraggingGoal = false;
    goalStartWorld = null;
    goalCurrentCanvas = null;
    return;
  }

  const rect = canvas.getBoundingClientRect();
  const cx = evt.clientX - rect.left;
  const cy = evt.clientY - rect.top;

  const endWorld = canvasToWorld(cx, cy);
  if (!endWorld) {
    isDraggingGoal = false;
    goalStartWorld = null;
    goalCurrentCanvas = null;
    return;
  }

  const dx = endWorld.x - goalStartWorld.x;
  const dy = endWorld.y - goalStartWorld.y;
  const yaw = Math.atan2(dy, dx);

  const goal = {
    x: goalStartWorld.x,
    y: goalStartWorld.y,
    yaw: yaw,
  };
  console.log("Sending goal", goal);

  try {
    const res = await fetch("/api/goal", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(goal),
    });
    const data = await res.json();
    console.log("Goal response", data);
  } catch (e) {
    console.error(e);
  }

  isDraggingGoal = false;
  goalStartWorld = null;
  goalCurrentCanvas = null;
  drawState();
});

// Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú ÏÉÅÌÉú Ìè¥ÎßÅ
setInterval(fetchState, 500);
fetchState();
</script>
</body>
</html>
