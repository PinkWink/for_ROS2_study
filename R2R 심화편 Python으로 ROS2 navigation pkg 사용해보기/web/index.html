<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Pinky Pro Web Nav Monitor</title>
  <style>
    :root {
      --pink-start: #ff6bb8;
      --pink-end: #ff9ad4;
      --blue-start: #5069d8;
      --blue-end: #7a9be8;
      --bg-dark: #0f172a;
      --card-bg: #0b1020;
      --border-subtle: rgba(255, 255, 255, 0.08);
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --accent: #ff9ad4;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      height: 100vh;
      display: flex;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top left, #201537, #020617 55%, #000000 100%);
      color: var(--text-main);
    }

    /* ì™¼ìª½: ë©”ì¸ ë§µ ì¹´ë“œ */
    #left {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .map-card {
      width: 100%;
      max-width: 900px;
      border-radius: 24px;
      padding: 16px 16px 20px 16px;
      background:
        radial-gradient(circle at top left, rgba(255, 155, 210, 0.12), transparent 55%),
        radial-gradient(circle at bottom right, rgba(104, 166, 255, 0.12), transparent 55%),
        var(--card-bg);
      box-shadow:
        0 20px 40px rgba(0, 0, 0, 0.8),
        0 0 0 1px rgba(255, 255, 255, 0.04);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      position: relative;
      overflow: hidden;
    }

    .map-card-header {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 4px 8px 4px;
    }

    .map-title {
      font-size: 16px;
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .map-title span {
      background: linear-gradient(135deg, var(--pink-start), var(--blue-end));
      -webkit-background-clip: text;
      color: transparent;
    }

    .chip {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(15, 23, 42, 0.7);
      backdrop-filter: blur(10px);
    }

    .chip-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: radial-gradient(circle, #22c55e, #15803d);
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.9);
    }

    canvas {
      border-radius: 18px;
      background: #000;
      border: 1px solid var(--border-subtle);
    }

    .map-hint {
      font-size: 12px;
      color: var(--text-muted);
    }

    /* ì˜¤ë¥¸ìª½: ì»¨íŠ¸ë¡¤ íŒ¨ë„ */
    #right {
      width: 320px;
      padding: 20px 18px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      border-left: 1px solid rgba(15, 23, 42, 0.9);
      background: radial-gradient(circle at top, rgba(248, 113, 185, 0.12), transparent 65%),
                  radial-gradient(circle at bottom, rgba(56, 189, 248, 0.12), transparent 65%),
                  #020617;
    }

    .panel-card {
      background: rgba(15, 23, 42, 0.85);
      border-radius: 18px;
      padding: 14px 14px 12px 14px;
      border: 1px solid var(--border-subtle);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.7);
    }

    /* í—¤ë” */
    .header-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .logo-wrap {
      width: 34px;
      height: 34px;
      border-radius: 12px;
      background: radial-gradient(circle at top left, var(--pink-start), var(--blue-start));
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .logo-wrap img {
      width: 28px;
      height: 28px;
      object-fit: contain;
      display: block;
    }

    .header-text-main {
      font-size: 14px;
      font-weight: 600;
    }

    .header-text-sub {
      font-size: 11px;
      color: var(--text-muted);
    }

    .info-line {
      font-size: 12px;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    .info-line span.value {
      color: var(--text-main);
      font-weight: 500;
      font-variant-numeric: tabular-nums;
    }

    /* ì„¹ì…˜ íƒ€ì´í‹€ */
    .section-title {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      margin-bottom: 6px;
    }

    /* í† ê¸€ ìŠ¤ìœ„ì¹˜ */
    .layer-row {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 0;
      font-size: 13px;
      color: var(--text-main);
    }

    .toggle-left {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
    }

    .legend-global {
      background: linear-gradient(135deg, #38bdf8, #22c1c3);
    }

    .legend-local {
      background: linear-gradient(135deg, #7c3aed, #4c1d95);
    }

    .legend-free {
      background: #ffffff;
      border: 1px solid #e5e7eb;
    }

    .legend-obstacle {
      background: #000000;
      border: 1px solid #111827;
    }

    .toggle input {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }

    .switch {
      width: 36px;
      height: 20px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.6);
      position: relative;
      cursor: pointer;
      transition: background 0.18s ease, border-color 0.18s ease;
    }

    .switch-knob {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      background: #e5e7eb;
      position: absolute;
      top: 2px;
      left: 2px;
      transition: transform 0.18s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }

    .toggle input:checked + .switch {
      background: linear-gradient(135deg, var(--pink-start), var(--blue-end));
      border-color: transparent;
    }

    .toggle input:checked + .switch .switch-knob {
      transform: translateX(14px);
      background: #0b1120;
    }

    /* Legend */
    .legend-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 10px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    /* ì‘ì€ í‘¸í„° í…ìŠ¤íŠ¸ */
    .tiny-note {
      margin-top: 4px;
      font-size: 11px;
      color: var(--text-muted);
    }
  </style>
</head>
<body>
<div id="left">
  <div class="map-card">
    <div class="map-card-header">
      <div class="map-title">Pinky Pro <span>Navigation</span></div>
      <div class="chip">
        <span class="chip-dot"></span>
        LIVE
      </div>
    </div>

    <canvas id="mapCanvas" width="720" height="720"></canvas>

    <div class="map-hint">
      ğŸ–±ï¸ ì§€ë„ì—ì„œ <b>í´ë¦­ í›„ ë“œë˜ê·¸</b>í•˜ë©´ 2D Nav Goal (ìœ„ì¹˜ + ë°©í–¥)ì´ ì „ì†¡ë©ë‹ˆë‹¤.
    </div>
  </div>
</div>

<div id="right">
  <!-- í—¤ë” ì¹´ë“œ -->
  <div class="panel-card">
    <div class="header-row">
      <div class="logo-wrap">
        <!-- ë¡œê³  íŒŒì¼ëª…ì„ í™˜ê²½ì— ë§ê²Œ ë³€ê²½í•˜ì„¸ìš” -->
        <img src="pinklab_logo.png" alt="PinkLab Logo">
      </div>
      <div>
        <div class="header-text-main">PinkLab Â· Pinky Pro</div>
        <div class="header-text-sub">Web Navigation Console</div>
      </div>
    </div>
    <div class="info-line">
      <span>Robot pose</span>
      <span class="value" id="poseText">-</span>
    </div>
    <div class="info-line">
      <span>Last update</span>
      <span class="value" id="updateText">-</span>
    </div>
  </div>

  <!-- Layers ì¹´ë“œ -->
  <div class="panel-card">
    <div class="section-title">Layers</div>
    <div class="layer-row">
      <label class="toggle">
        <div class="toggle-left">
          <span class="legend-dot legend-global"></span>
          <span>Global costmap</span>
        </div>
        <div>
          <input type="checkbox" id="toggleGlobal" checked>
          <div class="switch">
            <div class="switch-knob"></div>
          </div>
        </div>
      </label>

      <label class="toggle">
        <div class="toggle-left">
          <span class="legend-dot legend-local"></span>
          <span>Local costmap</span>
        </div>
        <div>
          <input type="checkbox" id="toggleLocal" checked>
          <div class="switch">
            <div class="switch-knob"></div>
          </div>
        </div>
      </label>
    </div>
  </div>

  <!-- Legend ì¹´ë“œ -->
  <div class="panel-card">
    <div class="section-title">Legend</div>
    <div class="legend-row">
      <span class="legend-item">
        <span class="legend-dot legend-free"></span>
        <span>Free</span>
      </span>
      <span class="legend-item">
        <span class="legend-dot legend-obstacle"></span>
        <span>Obstacle</span>
      </span>
      <span class="legend-item">
        <span class="legend-dot legend-global"></span>
        <span>Global costmap</span>
      </span>
      <span class="legend-item">
        <span class="legend-dot legend-local"></span>
        <span>Local costmap</span>
      </span>
    </div>
    <div class="tiny-note">
      ğŸ“Œ RVizì™€ ë™ì¼í•œ ì¢Œí‘œê³„(<b>map</b> frame ê¸°ì¤€)ì…ë‹ˆë‹¤.
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById("mapCanvas");
const ctx = canvas.getContext("2d");

let latestState = null;

// layer toggle ìƒíƒœ
let showGlobalCostmap = true;
let showLocalCostmap = true;

// goal ë“œë˜ê·¸ ìƒíƒœ
let isDraggingGoal = false;
let goalStartWorld = null;     // {x,y} world ì¢Œí‘œ
let goalCurrentCanvas = null;  // {x,y} canvas ì¢Œí‘œ (ë¯¸ë¦¬ë³´ê¸°ìš©)

// í† ê¸€ ì´ë²¤íŠ¸ ì—°ê²°
document.getElementById("toggleGlobal").addEventListener("change", (e) => {
  showGlobalCostmap = e.target.checked;
  drawState();
});

document.getElementById("toggleLocal").addEventListener("change", (e) => {
  showLocalCostmap = e.target.checked;
  drawState();
});

// ì„œë²„ì—ì„œ ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
async function fetchState() {
  try {
    const res = await fetch("/api/state");
    if (!res.ok) return;
    const data = await res.json();
    latestState = data;
    drawState();
    document.getElementById("updateText").innerText = new Date().toLocaleTimeString();

    if (data.pose) {
      const p = data.pose;
      document.getElementById("poseText").innerText =
        `x=${p.x.toFixed(2)}, y=${p.y.toFixed(2)}, yaw=${p.yaw.toFixed(2)}`;
    } else {
      document.getElementById("poseText").innerText = "-";
    }
  } catch (e) {
    console.error(e);
  }
}

// ë§µ / ë¡œë´‡ / ê²½ë¡œ / global/local costmap ê·¸ë¦¬ê¸°
function drawState() {
  if (!latestState || !latestState.map) {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    return;
  }

  const map = latestState.map;
  const pose = latestState.pose;
  const path = latestState.path || [];
  const local = latestState.local_costmap;
  const globalC = latestState.global_costmap;

  const width = map.width;
  const height = map.height;
  const data = map.data;
  const resolution = map.resolution;
  const origin = map.origin;

  // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // ë§µì„ ìº”ë²„ìŠ¤ì— ë§ê²Œ ìŠ¤ì¼€ì¼
  const scaleX = canvas.width / width;
  const scaleY = canvas.height / height;
  const scale = Math.min(scaleX, scaleY);

  // (ì…€ ì¢Œí‘œ -> ìº”ë²„ìŠ¤ ì¢Œí‘œ)
  function cellToCanvas(ix, iy) {
    const px = ix * scale;
    const py = (height - 1 - iy) * scale; // y ë’¤ì§‘ê¸°
    return [px, py];
  }

  // (world -> ìº”ë²„ìŠ¤)
  function worldToCanvas(wx, wy) {
    const mx = (wx - origin.x) / resolution;
    const my = (wy - origin.y) / resolution;
    return cellToCanvas(mx, my);
  }

  // ---- global map ê·¸ë¦¬ê¸° ----
  for (let iy = 0; iy < height; iy++) {
    for (let ix = 0; ix < width; ix++) {
      const idx = iy * width + ix;
      const v = data[idx]; // -1: unknown, 0: free, 100: occupied ...

      if (v < 0) {
        ctx.fillStyle = "#4b5563";    // unknown: ì¤‘ê°„ íšŒìƒ‰
      } else if (v === 0) {
        ctx.fillStyle = "#ffffff";    // free: í°ìƒ‰
      } else if (v >= 100) {
        ctx.fillStyle = "#000000";    // obstacle: ê²€ì •
      } else {
        ctx.fillStyle = "#d1d5db";    // ì•½ê°„ ë¹„ìš© ìˆëŠ” free
      }

      const [px, py] = cellToCanvas(ix, iy);
      ctx.fillRect(px, py, scale, scale);
    }
  }

  // ---- GLOBAL costmap (ì¸í”Œë ˆì´ì…˜ ë§) ì˜¤ë²„ë ˆì´ ----
  if (showGlobalCostmap && globalC && globalC.data && globalC.data.length > 0) {
    const gwidth = globalC.width;
    const gheight = globalC.height;
    const gres = globalC.resolution;
    const gorg = globalC.origin;
    const gdata = globalC.data;

    ctx.save();
    ctx.fillStyle = "rgba(56, 189, 248, 0.5)"; // ì—°í•œ í•˜ëŠ˜ìƒ‰/ì²­ë¡ìƒ‰

    for (let iy = 0; iy < gheight; iy++) {
      for (let ix = 0; ix < gwidth; ix++) {
        const idx = iy * gwidth + ix;
        const cost = gdata[idx];
        if (cost <= 0) continue;

        const wx = gorg.x + (ix + 0.5) * gres;
        const wy = gorg.y + (iy + 0.5) * gres;
        const [px, py] = worldToCanvas(wx, wy);

        ctx.fillRect(px, py, scale, scale);
      }
    }
    ctx.restore();
  }

  // ---- LOCAL costmap (ë³´ë¼ìƒ‰) ì˜¤ë²„ë ˆì´ ----
  if (showLocalCostmap && local && local.data && local.data.length > 0) {
    const lwidth = local.width;
    const lheight = local.height;
    const lres = local.resolution;
    const lorg = local.origin;
    const ldata = local.data;

    ctx.save();
    ctx.fillStyle = "rgba(124, 58, 237, 0.7)"; // ë³´ë¼ìƒ‰

    for (let iy = 0; iy < lheight; iy++) {
      for (let ix = 0; ix < lwidth; ix++) {
        const idx = iy * lwidth + ix;
        const cost = ldata[idx];
        if (cost <= 0) continue;

        const wx = lorg.x + (ix + 0.5) * lres;
        const wy = lorg.y + (iy + 0.5) * lres;
        const [px, py] = worldToCanvas(wx, wy);

        ctx.fillRect(px, py, scale, scale);
      }
    }
    ctx.restore();
  }

  // ---- path ê·¸ë¦¬ê¸° ----
  if (path.length > 0) {
    ctx.strokeStyle = "#22c55e";
    ctx.lineWidth = 2;
    ctx.beginPath();
    path.forEach((pt, i) => {
      const [px, py] = worldToCanvas(pt.x, pt.y);
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    });
    ctx.stroke();
  }

  // ---- ë¡œë´‡ ìœ„ì¹˜ (TF ê¸°ë°˜ pose) ----
  if (pose) {
    const [rx, ry] = worldToCanvas(pose.x, pose.y);
    ctx.fillStyle = "#f97316";
    ctx.beginPath();
    ctx.arc(rx, ry, 6, 0, 2 * Math.PI);
    ctx.fill();

    const len = 20;
    const hx = rx + len * Math.cos(-pose.yaw);
    const hy = ry + len * Math.sin(-pose.yaw);
    ctx.strokeStyle = "#fde68a";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(rx, ry);
    ctx.lineTo(hx, hy);
    ctx.stroke();
  }

  // ---- goal ë“œë˜ê·¸ ë¯¸ë¦¬ë³´ê¸° ----
  if (isDraggingGoal && goalStartWorld && goalCurrentCanvas) {
    const [sx, sy] = worldToCanvas(goalStartWorld.x, goalStartWorld.y);
    const ex = goalCurrentCanvas.x;
    const ey = goalCurrentCanvas.y;

    ctx.strokeStyle = "#fb7185";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(ex, ey);
    ctx.stroke();

    ctx.fillStyle = "#fb7185";
    ctx.beginPath();
    ctx.arc(ex, ey, 4, 0, 2 * Math.PI);
    ctx.fill();
  }
}

// canvas ì¢Œí‘œ â†’ world ì¢Œí‘œ ë³€í™˜ (map ê¸°ì¤€)
function canvasToWorld(cx, cy) {
  if (!latestState || !latestState.map) return null;

  const map = latestState.map;
  const width = map.width;
  const height = map.height;
  const resolution = map.resolution;
  const origin = map.origin;

  const scaleX = canvas.width / width;
  const scaleY = canvas.height / height;
  const scale = Math.min(scaleX, scaleY);

  const ix = cx / scale;
  const iy = height - 1 - (cy / scale); // y ë’¤ì§‘ê¸°

  const wx = origin.x + ix * resolution;
  const wy = origin.y + iy * resolution;

  return { x: wx, y: wy };
}

// ---- goal ì§€ì •: í´ë¦­ + ë“œë˜ê·¸ ----
canvas.addEventListener("mousedown", (evt) => {
  if (!latestState || !latestState.map) return;

  const rect = canvas.getBoundingClientRect();
  const cx = evt.clientX - rect.left;
  const cy = evt.clientY - rect.top;

  const w = canvasToWorld(cx, cy);
  if (!w) return;

  isDraggingGoal = true;
  goalStartWorld = w;
  goalCurrentCanvas = { x: cx, y: cy };
  drawState(); // ë¯¸ë¦¬ë³´ê¸° ê°±ì‹ 
});

canvas.addEventListener("mousemove", (evt) => {
  if (!isDraggingGoal) return;
  const rect = canvas.getBoundingClientRect();
  const cx = evt.clientX - rect.left;
  const cy = evt.clientY - rect.top;

  goalCurrentCanvas = { x: cx, y: cy };
  drawState();
});

canvas.addEventListener("mouseup", async (evt) => {
  if (!isDraggingGoal || !goalStartWorld) {
    isDraggingGoal = false;
    goalStartWorld = null;
    goalCurrentCanvas = null;
    return;
  }

  const rect = canvas.getBoundingClientRect();
  const cx = evt.clientX - rect.left;
  const cy = evt.clientY - rect.top;

  const endWorld = canvasToWorld(cx, cy);
  if (!endWorld) {
    isDraggingGoal = false;
    goalStartWorld = null;
    goalCurrentCanvas = null;
    return;
  }

  const dx = endWorld.x - goalStartWorld.x;
  const dy = endWorld.y - goalStartWorld.y;
  const yaw = Math.atan2(dy, dx);

  const goal = {
    x: goalStartWorld.x,
    y: goalStartWorld.y,
    yaw: yaw,
  };
  console.log("Sending goal", goal);

  try {
    const res = await fetch("/api/goal", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(goal),
    });
    const data = await res.json();
    console.log("Goal response", data);
  } catch (e) {
    console.error(e);
  }

  isDraggingGoal = false;
  goalStartWorld = null;
  goalCurrentCanvas = null;
  drawState();
});

// ì£¼ê¸°ì ìœ¼ë¡œ ìƒíƒœ í´ë§
setInterval(fetchState, 500);
fetchState();
</script>
</body>
</html>
